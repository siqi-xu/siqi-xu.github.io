---
title: "Http Cache"
layout: post
date: 2016-05-02
permalink : /post/http-cache
tag:
- HTTP
blog: true
---

# HTTP 缓存

## 关键字

- 命中 控制缓存 文档过期 使用期 过期时间 新鲜度 再验证 命中率
- Cache-Control Exipres If-None-Match Etags 

## 为什么需要缓存？

- 减少冗余的数据传输。节省网络费用；客户端访问多次访问同一个页面，服务器多次传输同一份文档，一些相同的字节会在网络中重复的传输，消耗有限的带宽，降低传输速度，加重Web服务器的负载。缓存可以保留第
- 缓解网络瓶颈问题。不用花更多带宽就能够更快加载页面；很多网络为本地网络客户端提供的带宽比为远程服务器提供的带宽要宽。客户端会以路径上最慢的网速访问服务器。如果客户端从一个快速局域网的缓存中得到一份副本，那么缓存就能提高性能
- 降低对原始服务器的要求。服务器能更快响应。瞬间拥塞：突发的时间会使我们几乎同时访问同一个Web文档，由此造成的流量峰值可能使网络和Web服务器崩溃
- 降低距离时延。每经过一台路由器都会增加流量的时延，即使客户端和服务器之间没有太多的路由器，光速本身也会有显著的时延。(比如下载个文档整个过程只需要240ms，但是就光速本身使用了50ms)如果距离近的话就能够减少距离时延。

注意：这里的缓存不仅仅是指浏览器上的本地缓存，也可能是某个缓存服务器(如Redis服务器)


## 如何保持最新副本

### 流程

![](http://7xpld9.com1.z0.glb.clouddn.com/%E7%BC%93%E5%AD%98%E5%A4%84%E7%90%86.png)


### 命中和未命中

可以用已有的缓存副本为某些到达的请求提供服务，称为缓存命中；
其他一些到达请求可能由于没有可用副本，而转发到原始服务器，称为缓存未命中。


### 控制缓存新鲜度

使用 Cache-Control 或 Expires 控制缓存**使用期**或**过期时间**(新鲜度)

- Cache-Control:no-cache 表示保存缓存副本，但是下次请求时需要到服务器验证新鲜度
- Cache-Control:no-store 表示不保存缓存
- Cache-Control:max-age=3600 表示缓存新鲜度保持时间

### 再验证(新鲜度检测)

原始服务器的内容可能会发生变化，缓存需要对其进行检查，保证保存的副本是服务器上最新的副本。这些**新鲜度检测**被称为**HTTP再验证**

当**文档过期**后，为了进行新鲜度检测，HTTP定义了特殊的请求，不用从服务器上获取整个对象，就能快速检测出内容是不是最新的，如果内容没有变化，服务器会以304 Not Modified进行响应。缓存知道副本仍然有效，就会再次将副本标记为暂时新鲜，并直接将副本提供给客户端，这称为**再验证命中**

这种方式因为需要与原始服务器比对，所以比单纯的缓存命中要慢，但它没有从服务器获取整个对象，因此比缓存未命中更快

虽然说缓存可以在任何频率发起验证，但是由于缓存中包含的文档很多，为了节省带宽，一般只有在客户端再次发出请求的时候再对缓存的副本同时校验。

HTTP提供了几个对已缓存对象进行再验证的请求首部，常用的有 If-Modified-Since 和 If-None-Match。将这个首部添加到请求中，就告诉服务器，只有在缓存了对象的副本后，又对其进行了更改的情况下，才发送此最新对象。

此时会有3种情况：

1. 在验证命中：服务器对象未被修改，服务器会想客户端发送HTTP 304 Not Modified
2. 再验证未命中：服务器向客户端发送一条带有完整内容的 HTTP 200 OK 响应
3. 对象被删除：服务器发送 404 Not Found响应，同时删除已缓存的副本


### 强弱验证器

缓存通过某种方式与服务器对比已缓存的版本是不是最新的。所以实体标签和最近修改时间都是验证缓存器

- 弱验证器，对文档的更改，不要使缓存副本失效
- 强验证器：只要内容变化，强验证器就会发生变化，缓存副本失效

If-Modified-Since：Date 是弱验证器。如果文档在1s内发生无数次变化，但是修改时间是不会变的，Date 只是精确到s。
If-None-Match：实体标签 是强验证器。实体一变化，缓存立即失效

如果需要使用If-None-Match作为若验证器。可以这样： If-None-Match: W/"v2.6"


## 命中率 (cache hit rate)

由缓存提供服务的请求所占的比例称为缓存命中率，从0%到100%之间。服务器方希望缓存命中率接近100%，但是实际的命中率会受缓存大小，缓存数据的变化频率和缓存配置等的影响。一般40%命中率是合理的

字节命中率：有些大的对象虽然访问次数少，但是对整个网络的流量影响大，因为，有人使用**字节命中率**(byte hit rate)作为度量值。

字节命中率指缓存提供的字节在传输的所有字节中所占的比例。可以得知节省流量的程度。


## 小结


第一次访问：

请求不会带有 If-None-Match(或 HTTP/1.0 If-Modified-Since)，而响应会返回 ETags (或 Last-Modified)。(注意：第一次访问的意思指不存在缓存副本)

第二次访问：

1. 如果第一次访问时响应首部有 Cache-Control (或 HTTP/1.0 Expires )且未过期，说明副本一定是新鲜的，将不会向服务器发起请求
2. 如果第一次访问响应文档已过期( Cache-Control 到期)或不存在 Cache-Control 首部，会认为副本可能已经不是最新的，才会在请求中加入 If-None-Match 首部以再验证新鲜度，If-None-Match 的值为上一次响应返回的 ETags的值。如果再验证显示内容没有发生变化的，缓存只获取新的首部，包括一个新的过期时间，并对缓存的首部进行更新；否则从原始服务器发送最新的对象给客户端，同时更新副本。



HTTP 协议要求行为正确的缓存返回下列内容之一：

- "足够新鲜"的已缓存副本 200 OK (from cache)
- 与服务端进行过再验证，确定其仍然新鲜的已缓存副本 304 Not Modified 
- 如果需要与之再验证的原始服务器出故障，返回一个错误报文 404